## 8.1 模拟赛 Solution

### A

注意到我们没有必要在绿灯的时候等, 所以直接跑 dijkstra, 然后每次计算一下下一次绿灯是什么时候即可。

时间复杂度 $O(m \log n)$

### B

首先每个数只有质因子有用，所以我们只需要保留每个数质因子的乘积即可。

那么通过简单的容斥或莫比乌斯反演我们可以将我们要求的 $\sum_{i,j}[gcd(v_i,v_j)=1]$ 转化为 $\sum_{g}\mu(g) \sum_{i,j} [g|v_i,g|v_j]$

那么考虑假设我们要在路径中加入一个点或者删除一个点, 我们最多只需要枚举8个不同的$g$ 并计算当前路径中有多少数是 $g$ 的倍数，也就是说插入和删除的维护和更新可以在 $O(1)$ 完成。

假设树的形态是一条链且我们可以快速的进行插入和删除，那么我们直接使用序列莫队的技巧即可。

对于一般的情况我们可以使用树上莫队的技巧，首先对树跑一边dfs, 在进入每个点(开始位置)和走出每个点(结束位置)的时刻同时记录, 这样就得到了一个长度为 $2n$ 的序列，序列上的相邻元素在树上也相邻。注意到如果要统计树上的一条路径 $(u,v)$ 那么我们只需要将 $u$ 的结束位置到 $v$ 的开始位置对应序列的区间取出, 忽略出现两次的元素, 剩余的出现正好一次的元素再加上lca就是路径上的点集。 注意如果 $u$ 是 $v$ 的祖先需要特判。 

于是就将树上莫队转化成了序列莫队问题求解。

最终时间复杂度 $O(m\sqrt n)$

### C

首先不难想到直接最短路计算, 记 $f(i,j)$ 表示跳到 $(i,j)$ 最少使用的体力。 那么转移就是枚举上一个位置然后加上曼哈顿距离求最小值。

考虑优化，我们注意到如果转移都在左上的话坐标正负的贡献是固定的, 所以可以使用数据结构维护。先按照一维扫描线，另一维可以使用线段树或者树状数组维护前缀/后缀最小值。

对于四个象限分别计算一次即可。

时间复杂度 $O(n^2 \log n)$

### D

首先我们注意到任意两个秘密据点的路径中点是重要的，为了让这个中点不出现在边上一个常见的技巧就是在每条边上新建一个点。

然后我们先考虑在扩建了树之后每个 $M$ 值的改变，原先树上的点 $M$ 值会变成两倍。 考虑原图中的边 $(u,v)$ 中间新建的点 $x$ 那么首先必须有 $|M_u-M_v|\le 2$ 如果 $|M_u-M_v|=2$ 那么 $M_x=(M_u+M_v)/2$. 如果 $M_u=M_v$ 这时候这条边中点 $x$ 一定是某两个秘密据点的中点，也就是说这种边最多只有3个。这些 $M_x=M_u \pm 1$, 可以直接暴力枚举。

接着我们考虑 $u_1,u_2,u_3$ 的位置关系，它们三个点一定有一个中心 $u$, 不妨记 $D_i=d(u,u_i)$, 并且假设 $D_1\le D_2\le D_3$.

我们按照 $M$ 值从大到小给边定向, 如果一个点没有出度则称为汇点。 通过观察: 当 $D_1<D_2\le D_3$ 的时候有且只有两个汇点。 当 $D_1=D_2\le D_3$ 的时候有且只有一个汇点。计算出汇点的个数分类讨论。

一个汇点的情况: 此时汇点一定是三个点的中心, 设汇点为 $r$, 且 $D_1=D_2=M_r,D_3>M_r$ 我们只需要通过简单的背包的$dp$ 计数即可。

两个汇点的情况: 设两个汇点为 $r_1,r_2$. 我们会发现 $u_1,u_2,u_3$ 的点到 $r_1,r_2$ 的距离已经全部确定了，只要分别独立的满足这些距离, 将方案数相乘即可，两次 dfs 即可。

最终时间复杂度 $O(n)$